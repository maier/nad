#!/usr/bin/env node
// #!/bin/sh
// ':' // ; exec "$(command -v node)" --expose-gc --throw-deprecation --trace-warnings "$0" "$@"
// -*-Javascript-*-

/* eslint-disable no-process-exit */
/* eslint-disable no-sync */
/* eslint-disable no-bitwise */
/* eslint-disable no-mixed-operators */
/* eslint-disable global-require */
/* eslint-disable no-plusplus */
/* eslint-disable no-param-reassign */
/* eslint-disable guard-for-in */
/* eslit-disable no-nested-ternary */
/* eslint-disable max-params */

'use strict';

//
// Toss executables (scripts too) in /etc/node-agent.d
// Each program should produce lines as follows:
//    <name><whitespace><type>
// or:
//    <name><whitespace><type><whitespace><value>
//
// The first indicates the value is present and null
// the second indicates the value is present and specific
//

// require //////////////////////////////////////////////////////////////

const fs = require('fs');
const http = require('http');
const https = require('https');
const path = require('path');
const spawn = require('child_process').spawn;
const url = require('url');

const settings = require('settings');
const log = settings.logger.child({ module: 'main' });

log.info('initializing');

// only load if it's going to be used. (if metric debugging is activated)
let dutil = null;

// only load if it's going to be used. (if this is windows)
let circwmi = null;

if (settings.is_windows) {
    try {
        circwmi = require('circwmi');
    } catch (err) {
        const msg = 'unable to load circwmi module';

        console.error(settings.prefixError, msg, err);
        log.fatal({ err }, msg);
        process.exit(1);
    }
}

// "globals" ///////////////////////////////////////////////////////////

// cache of previous results of running scripts
// this is responded with if a script is still running when
// a request for a new value comes in (which is common with long
// running scripts that periodically output values)
const past_results = {};

// a data structure representing all scripts (aka plugins/native
// plugins.)  Each value in the object contains an object that
// has properties relating to the script.
const scripts = {};

// a collection indicating which scripts that have been run once
// already
const scripts_once = {};

// listener for metrics (see protocol_observer usage in postgres and cassandra plugins)
let push_script = null;

// The script "generation".  A global counter that's incremented
// each time we scan for new scripts on disk.
let generation = 0;


// //////////////////////////////////////////////////////////////////////
// setuid
// //////////////////////////////////////////////////////////////////////

function post_boot() {
    settings.is_booted = true;

    if (settings.drop_uid > 0 && process.setuid) {
        log.info({ uid: settings.drop_uid }, 'dropping privileges');
        process.setuid(settings.drop_uid);
    }

    if (settings.reverse.enabled) {
        log.info('setting up reverse connection');
        let reverse = null;

        try {
            reverse = require('reverse');
        } catch (err) {
            console.error(err);
            log.fatal({ err }, 'unable to set up reverse connection');
            process.exit(1);
        }

        let api_options = url.parse(settings.api.url);

        if (!settings.api.use_apiurl) {
            api_options = settings.api.old_options;
        }

        const options = {
            cafile: settings.reverse.broker_ca,
            hostname: settings.hostname,
            apiKey: settings.api.key,
            apiApp: settings.api.app,
            api_options,
            check_bundle_id: settings.reverse.check_bundle_id,
            server_port: settings.listen[0].port
        };

        reverse(options, log);
    }


    if (global.gc) {
        setInterval(() => {
            log.info('running gc');
            global.gc();
        }, 300 * 1000);
    }


    log.debug('bootstrap complete');
}

// //////////////////////////////////////////////////////////////////////
// executing scripts
// //////////////////////////////////////////////////////////////////////

// merge_types takes two char type descriptors and returns the
// smallest type that could non-erroneously represent them
function merge_types(typeA, typeB) {
    if (typeA === typeB) {
        return typeA;
    }
    // There are four source cases where we can upgrade to int64_t
    if (typeA === 'i' && (typeB === 'I' || typeB === 'l')) {
        return 'l';
    }
    if (typeA === 'I' && (typeB === 'i' || typeB === 'l')) {
        return 'l';
    }
    if (typeA === 'l' && (typeB === 'i' || typeB === 'I')) {
        return 'l';
    }
    if (typeA === 'L' && typeB === 'I') {
        return 'l';
    }
    // otherwise we have to just jump to a double
    return 'n';
}

// runs a single script / native plugin and then fires a callback
//   plugin is the object for the script that's stored in 'scripts'
//   cb is what we call back when done
//   req is the request object (passed to native plugins)
//   args is any arguments that came from the per script config file
//   instance is the specific instance of plugin to run
function run_script(plugin, cb, req, args, instance) {

    log.info({ name: instance }, 'running plugin');

    // (we don't re-run scripts that are already running)
    plugin.running = true;
    plugin.last_start = Date.now();

    // per process data
    const proc_data = {
        // incomplete line of data buffered between callbacks.
        data: '',

        // complete lines of data that have yet to
        // be handled (parsed for JSON and/or tab
        // file format.)  We only parse the output
        // when we reach the end of the output or a
        // blank line
        lines: [],

        options: {}
    };

    // if this is a native plugin then all we need to do
    // is call the run method on the instance stored within d.obj
    // and we're done, so return
    if (plugin.native_plugin) {
        plugin.obj.run(plugin,
            (_plugin, _metrics, _instance) => {
                past_results[_instance] = _metrics;
                cb(_plugin, _metrics, _instance);
            }, req, args, instance);
        return;
    }

    // execute the command
    const cmd = spawn(plugin.command, args);

    function kill_func() {
        cmd.stdin.destroy();
        cmd.stdout.destroy();
        cmd.stderr.destroy();
        cmd.kill();
    }

    // create a function that can handle output from the process we
    // just created.  This will be called from the code below whenever
    // we reach the end of the process output, or a blank line is found in
    // the output
    function handle_output(pluginDef, pluginCB, pluginInstance) {
        if (proc_data.timeout) {
            clearTimeout(proc_data.timeout);
        }
        pluginDef.last_finish = Date.now();
        let results = {};

        // if someone has specified a debug dir, then log out
        // the record we collected to that
        if (settings.debug_dir !== null) {
            dutil.write_debug_output(pluginDef.name, proc_data.lines, settings.debug_dir, settings.wipe_debug_dir);
        }

        // attempt to process the lines as json...
        try {
            results = JSON.parse(proc_data.lines.join(' '));
        } catch (err) {
            // ... but if that doesn't work, try the tab delim format
            for (const line of proc_data.lines) {
                const parts = (/^\s*(metric\s+)?(\S+)\s+(string|int|float|[iIlLns])(\s*)(.*)$/).exec(line);

                if (parts) {
                    const name = parts[2];
                    let type = parts[3];
                    const space = parts[4];
                    const val = parts[5];
                    const isnull = space.length === 0 || val === '[[null]]';

                    type = type.length > 1 ? type === 'float' ? 'n' : type.substr(0, 1) : type; // eslint-disable-line no-nested-ternary

                    if (type !== 's' &&  // this is numeric
                        {}.hasOwnProperty.call(results, name) && results[name]._type !== 's' && // preexists as numeric
                        {}.hasOwnProperty.call(results[name], '_value')) {
                        if (!Array.isArray(results[name]._value)) { // upgrade to array
                            results[name]._value = [ results[name]._value ];
                        }
                        // we're in a position to append the result instead of set it.
                        results[name]._value.push(isnull ? null : val);
                        // we also might need to "upgrade the type"
                        results[name]._type = merge_types(type, results[name]._type);
                    } else {
                        results[name] = {
                            _type: type,
                            _value: isnull ? null : val
                        };
                    }
                }
            }
        }

        // remember the past results
        past_results[pluginInstance] = results;

        // execute the callback
        pluginCB(pluginDef, results, pluginInstance);
    }

    // hook up the process so whenever we complete reading data
    // from the process we call "handle_output" and process
    // any remaining data (i.e. any partial line still in
    // our between callback buffer)
    cmd.stdout.on('end', () => {
        handle_output(plugin, cb, instance);
    });

    // hook up an anonymous function to the process to be called
    // whenever we get output.  The way this works is basically
    // there's two buffers used between calls: proc_data.lines
    // representing all lines of data we haven't processed yet
    // and proc_data.data representing an incomplete line
    cmd.stdout.on('data', (buff) => {
        let offset = null;

        // append output we collected to the incomplete line buffer
        // we're using to cache data between "data" callbacks
        proc_data.data += buff;

        // extract each complete line of data that's in the
        // between callback buffer and leave only the remaining
        // incomplete line in that buffer
        while ((offset = proc_data.data.indexOf('\n')) >= 0) {
            // extract a single line of data from the start of the string
            // pay attention to windows line endings if there are any!
            const line = proc_data.data.substring(0,
                     offset > 0 &&
                      proc_data.data.charAt(offset - 1) === '\r' ?
                         offset - 1 : offset);

            // is this a "comment" that contains meta information in a JSON blob?
            if (line.charAt(0) === '#') {
                try {
                    proc_data.options = JSON.parse(line.substring(1));
                } catch (err) {
                    log.error({ err }, 'processing proc options');
                }

                // set a timeout to stop this run if requested in meta block
                if (proc_data.options.timeout) {
                    proc_data.timeout = setTimeout(kill_func,
                                         proc_data.options.timeout * 1000);
                }
            } else if (line.length > 0) {
                // if line has data, addd to collected lines
                proc_data.lines.push(line);
            } else {
                // if a blank line, process collected lines
                handle_output(plugin, cb, instance);
            }

            // discard this line from the buffer we're using between
            // "data" callbacks and move onto processing the next one
            // if there is (or keep it for next callback if there isn't)
            proc_data.data = proc_data.data.substring(offset + 1);
        }
    });

    // when the command is done, mark it as no longer running.
    cmd.on('exit', (code, signal) => {
        if (code !== 0) {
            log.warn({ name: instance, cmd: plugin.command, code, signal }, 'plugin exit code non-zero');
        }
        plugin.running = false;
    });

  // if there's any error running the command, log it and remove it from the list
    cmd.on('error', (err) => {
        log.error({ name: instance, err, cmd: plugin.command }, `command error, removing from plugin list`);
        proc_data.data = '';
        plugin.running = false;
        delete scripts[plugin.name];
    });
}

// per script config
function get_config(req, plugin, cb) {
    // short-circuit if the plugin doesn't have a config
    if (!plugin.config) {
        run_script(plugin, cb, req, [], plugin.name);
        return;
    }

    log.debug({ name: plugin.name, config: plugin.config }, 'applying plugin config');

    const instance_count = Object.keys(plugin.config).length;

    // Add the number of time we will run this script to our
    // total run_count so we don't finish early.
    if (req && instance_count > 1) {
        req.nad_run_count += instance_count - 1;
    }

    for (const instance in plugin.config) {
        run_script(plugin, cb, req, plugin.config[instance], `${plugin.name}\`${instance}`);
    }
}

function init_script(plugin, req, cb) {
    log.debug({ name: plugin.name }, 'initializing plugin');
    if (plugin.running) {
        log.debug({ name: plugin.name }, 'plugin already running, returning previous result');
        cb(plugin, past_results[plugin.name], plugin.name);
        return;
    }
    get_config(req, plugin, cb);
}


if (settings.debug_dir !== null) {
    try {
        dutil = require('debug_util');
    } catch (err) {
        const msg = 'unable to load debug_util module';

        console.error(settings.prefixError, msg, err);
        log.fatal({ err }, msg);
        process.exit(1);
    }
}

// //////////////////////////////////////////////////////////////////////
// scanning for plugins (both native and non-native)
// //////////////////////////////////////////////////////////////////////

// a handy function returning a callback that will
// determine if a file has changed on not.
// Used by rescan_modules
function onchange(cb) {
    return (curr, prev) => {
        if (curr.ino !== prev.ino ||
            curr.size !== prev.size ||
            curr.mtime.valueOf() !== prev.mtime.valueOf() ||
            curr.mode !== prev.mode) {
            cb();
            return;
        }
    };
}

// run each script in scripts that hasn't had an initial
// run yet (and then remember it _has_ had an initial run)
function initial_pass() {
    log.debug('initial pass');

    for (const which in scripts) {
        if (!(which in scripts_once)) {
            init_script(scripts[which], null, () => {});
            scripts_once[which] = true;
        }
    }

    if (!settings.is_booted) {
        post_boot();
    }
}


// look on disk for updates to the config dir where
// we keep all our modules (aka plugins / aka scripts)
function rescan_modules() {

    log.debug({ dir: settings.plugin_dir }, 'scanning for plugins');

    // this keeps track of how many filesystem stats we have
    // "in progress" and are still waiting for callbacks on
    let progress = 0;

    // generation is the global number of times rescan_modules has been
    // called.  Each time we rescan our modules we increase it
    // by one.
    generation++;

    // this is a handy private function that goes through
    // all the scripts in our scripts object and removes
    // any that haven't had their generation number updated
    // to our current generation number once we've done
    // scanning
    function sweep() {
        // don't do this while we're still waiting for
        // stat requests that are in progress
        if (progress !== 0) {
            return;
        }

        log.debug('sweep');

        // clear out any out of date scripts
        for (const script in scripts) {
            if (scripts[script].generation < generation) {
                log.debug({ name: script.name }, 'removing expired plugin');
                fs.unwatchFile(scripts[script].command);
                delete scripts[script];
                delete scripts_once[script];
            }
        }

        // run the initial run for any new scripts
        initial_pass();
    }

    function genStatCallback(name, file) {
        return (err, sb) => {
            if (err !== null) {
                log.warn({ err, file }, 'unable to stat file');
                return;
            }

            if (!sb) {
                log.warn({ sb, file }, 'bad stat object for file');
                return;
            }

            if (!sb.isFile()) {
                log.debug({ dir_entry: name }, 'ignoring, not a file');
                return;
            }

            const is_native = (/\.js$/).test(file);
            const is_executable = sb.mode & parseInt('0111', 8);

            if (!(settings.is_windows || is_native || is_executable)) {
                log.debug({ dir_entry: name }, 'ignoring, not a valid file');
                return;
            }

            // if the file is something we should deal with
            // (is a file, and either ends in .js or is executable, or we're running on
            // windows where everything is considered executable)

            log.debug({ name }, 'found plugin');
                // watch the file for future updates.  i.e. if the file changes
                // again later then retrigger this rescan_modules routine
            fs.watchFile(file, onchange(rescan_modules));
                // setup the details in the scripts object for this file
            if (!(name in scripts)) {
                scripts[name] = {};
            }
            const def = scripts[name];

            def.name = name;
            def.generation = generation;
            def.command = file;
            def.native_plugin = is_native;
            def.running = false;
            def.sb = sb;
            def.config = null;

            const cfgFile = path.join(settings.plugin_dir, `${name}.json`);

            if (fs.existsSync(cfgFile)) {
                try {
                    def.config = require(cfgFile);
                } catch (cfgErr) {
                    if (cfgErr.code !== 'MODULE_NOT_FOUND') {
                        const msg = 'error loading config file';

                        console.error(settings.prefixError, msg, cfgErr);
                        log.fatal({ err: cfgErr, file: cfgFile }, msg);
                        process.exit(1);
                    }
                }
            }

            // if this is a "native plugin", i.e. a plugin written in
            // javascript with a ".js" extension then simply load
            // the code directly into node and then create
            // an instance 'obj' to shove in the scripts data structure
            if (def.native_plugin) {
                let Plugin = null;

                try {
                    Plugin = require(def.command);
                } catch (perr) {
                    const msg = 'unable to load native plugin';

                    console.error(settings.prefixError, msg, def.command, perr);
                    log.fatal({ err: perr, file: def.command }, msg);
                }

                def.obj = new Plugin();
            }

                // Only remove items on initial scan
            if (generation === 1 && settings.debug_dir !== null) {
                dutil.init_debug(name, settings.debug_dir);
            }

            progress--;
            sweep();
        };
    }

    // look in the config directory
    fs.readdir(settings.plugin_dir, (err, files) => {

        // bomb out if there's any error (we don't do any fancy
        // error handling or attempt any form of recovery)
        if (err) {
            const msg = 'unable to read config directory';

            console.error(settings.prefixError, msg, err);
            log.fatal({ err, dir: settings.plugin_dir }, msg);
            process.exit(-1);
        }

        // inc our reference count
        progress++;

        // for each file in the config directory
        for (const file of files) {
            const fileParts = path.parse(path.join(settings.plugin_dir, file));

            // if file is not in form name.extension, ignore
            if (fileParts.name === '' || fileParts.ext === '') {
                log.debug({ dir_entry: file }, 'ignoring, invalid name');
                continue;
            }

            // if a configuration file, ignore
            if (fileParts.ext === '.conf' || fileParts.ext === '.json') {
                log.debug({ dir_entry: file }, 'ignoring, config file');
                continue;
            }

            const filename = path.join(fileParts.dir, fileParts.base);

            // stop watching the file for updates
            fs.unwatchFile(filename);

            // note we need to wait for stat callback to be
            // called before we're done
            progress++;

            // stat the file
            fs.stat(filename, genStatCallback(fileParts.name, filename));
        }
        progress--;
        sweep();
    });
}


// this is called from the "webserver" part, it's job is:
//   1. Run all scripts
//   2. Put the output as JSON into the passed result
function run_scripts(req, res, which) {
    log.info({ which }, 'running plugin(s)');

    // this is a per-request counter that lets us know
    // when all scripts have returned and it's safe to
    // stringify out the output.
    req.nad_run_count = 0;

    // this is the data structure we're going to populate
    // with the results and eventually stringify out as JSON
    const set = {};

    // called when complete to actually send 'set' out as JSON
    function send_complete() {
        if (req.nad_run_count !== 0) {
            return;
        }
        if (settings.sendNADStats) {
            set.nad = {
                cpu: process.cpuUsage(),
                memory: process.memoryUsage(),
                uptime: process.uptime()
            };
        }
        res.writeHead(200, { 'Content-Type': 'application/json' });
        res.write(JSON.stringify(set));
        res.end();
    }

    // if they asked for a particular script and it didn't exist
    // then just send a 404
    if (which && !(which in scripts)) {
        res.writeHead(404);
        res.end();
    } else {
        // otherwise we're going to populate "set" and send it back
        // either just with the script they asked for in which or,
        // if nothing was passed in which, with every script

        // first work out how many scripts we're going to wait to run
        for (const file in scripts) {
            if (which && file !== which) {
                continue;
            }
            req.nad_run_count++;
        }

        // add one for the push_script
        if (!which && push_script !== null) {
            req.nad_run_count++;
        }

        // call init script for each script (which will run it) and
        // then when it returns in the callback populate set with
        // the result.  Keep track of how many scripts are left to run
        for (const file in scripts) {
            if (which && file !== which) {
                continue;
            }
            init_script(scripts[file], req, (def, results, name) => {
                req.nad_run_count--;
                set[name] = results;
                send_complete();  // only sends if all scripts are done
            });
        }

        // call the global push receiver script to spit out anything collected over http
        if (!which && push_script !== null) {
            init_script(push_script, req, (def, results, name) => {
                req.nad_run_count--;
                if (results !== null) {
                    for (const group in results) {
                        set[group] = results[group];
                    }
                    if (settings.debug_dir !== null) {
                        dutil.write_debug_output(name, [ 'Returning push_receiver data', JSON.stringify(results) ], settings.debug_dir, settings.wipe_debug_dir);
                    }
                }
                send_complete();  // only sends if all scripts are done
            });
        }

        send_complete(); // only sends if there were no scripts to run
    }
}

// //////////////////////////////////////////////////////////////////////
// process web requests
// //////////////////////////////////////////////////////////////////////

// this is the callback that's called whenever something connects
// to our webserver (either any of the http or the https servers)

function handler(req, res) {
    const bodyChunks = [];

    req.addListener('data', (chunk) => {
        bodyChunks.push(chunk);
    });

  // wait for the request to be completely formed (by registering
  // a callback on the 'end' event) and then send back the result
    req.addListener('end', () => {
        let matches = null;
        const urlPath = url.parse(req.url).pathname;
        const body = Buffer.concat(bodyChunks).toString();

        // request for meta-info about the scripts
        if (/^\/inventory/.test(urlPath)) {
            log.debug('inventory request');
            res.writeHead(200, { 'Content-Type': 'application/json' });
            res.write(JSON.stringify(scripts));
            res.end();
            return;
        }

        // request to run all scripts and return results
        if (/^\/(?:run)?$/.test(urlPath)) {
            log.debug('running all scripts');
            run_scripts(req, res);
            return;
        }

        // request to run just one script and return results
        matches = (/^\/run\/(.+)$/).exec(path);
        if (matches) {
            log.debug({ script: matches[1] }, 'running plugin');
            run_scripts(req, res, matches[1]);
            return;
        }

        // wmi
        if (settings.is_windows) {
            if ((/^\/wmi\/get-categories$/).test(path)) {
                log.debug('wmi categories request');
                circwmi.get_categories(res);
                return;
            }
            matches = (/^\/wmi\/(.+)$/).exec(path);
            if (matches) {
                log.debug({ category: matches[1] }, 'wmi counters request');
                circwmi.get_counters_for_category(res, matches[1], settings.debug_dir, settings.wipe_debug_dir);
                return;
            }
        }

        // push plugin
        if (push_script !== null) {
            matches = (/^\/write\/(.+)$/).exec(path);
            if (matches) {
                if (req.method !== 'PUT' && req.method !== 'POST') {
                    res.writeHead(405, 'Method Not Allowed', { Allow : 'PUT, POST' });
                    res.end();
                    return;
                }
                log.debug({ name: matches[1] }, 'write request');
                if (settings.debug_dir !== null) {
                    dutil.write_debug_output(matches[1], [ 'Receiving push_receiver data', body ], settings.debug_dir, settings.wipe_debug_dir);
                }
                push_script.obj.some_data(matches[1], body);
                res.writeHead(200, 'OK', { 'Content-Type': 'text/plan' });
                res.end();
                return;
            }
        }

        // otherwise... consider it an invalid request

        log.debug({ path }, 'invalid request');
        res.writeHead(404);
        res.end();
    });

    // if we don't have a data listener the stream starts paused in node 10+
    req.addListener('data', () => {});
}

// initialize: look for modules, and register a handler to
// rescan the modules every time the directory with the modules
// in it changes
fs.watchFile(settings.plugin_dir, onchange(rescan_modules));
rescan_modules();

// add our specialized push script that handles incoming POST data from any local data spurters
try {
    log.debug('loading push receiver');

    let PushReceiver = null;

    try {
        PushReceiver = require('push_receiver');
    } catch (err) {
        const msg = 'failed to load push_recever module';

        console.error(settings.prefixError, msg, err);
        log.fatal({ err }, msg);
        process.exit(1);
    }

    // NOTE: this *simulates* a regular plugin
    push_script = {
        name: 'dumpster',
        native_plugin: true,
        running: false,
        obj: new PushReceiver()
    };

    log.info('push receiver loaded');

} catch (err) {
    const msg = 'unable to initialize push receiver';

    console.log(settings.prefixError, msg, err);
    log.fatal({ err }, msg);
    process.exit(1);
}

// //////////////////////////////////////////////////////////////////////
// start webservers
// //////////////////////////////////////////////////////////////////////

for (const server of settings.listen) {
    log.debug({ server }, 'starting server');

    try {
        http.createServer(handler).listen(server.port, server.address);
        log.info({ server }, 'started');
    } catch (err) {
        const msg = 'failed to start server';

        console.error(settings.prefixError, msg, server, err);
        log.fatal({ server, err }, msg);
        process.exit(-1);
    }
}

for (const server of settings.ssl.listen) {
    log.debug({ server }, 'starting SSL server');

    try {
        https.createServer(settings.ssl.creds, handler).listen(server.port, server.address);
        log.info({ server }, 'started (SSL)');
    } catch (err) {
        const msg = 'failed to start SSL server';

        console.error(settings.prefixError, msg, server, err);
        log.fatal({ server, err }, msg);
        process.exit(-1);
    }
}

// END
