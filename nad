#!/usr/bin/env node
// -*-Javascript-*-

/* eslint-disable no-process-exit */
/* eslint-disable no-sync */
/* eslint-disable no-bitwise */
/* eslint-disable no-mixed-operators */
/* eslint-disable global-require */
/* eslint-disable no-plusplus */
/* eslint-disable no-param-reassign */
/* eslint-disable new-cap */
/* eslint-disable guard-for-in */
/* eslit-disable no-nested-ternary */
/* eslint-disable max-params */

'use strict';
//
// Toss executables (scripts too) in /etc/node-agent.d
// Each program should produce lines as follows:
//    <name><whitespace><type>
// or:
//    <name><whitespace><type><whitespace><value>
//
// The first indicates the value is present and null
// the second indicates the value is present and specific
//

// require //////////////////////////////////////////////////////////////

const fs = require('fs');
const os = require('os');
const tls = require('tls');
const http = require('http');
const https = require('https');
const url = require('url');
const path = require('path');
const crypto = require('crypto');
const spawn = require('child_process').spawn;

const pino = require('pino');
const logger = pino({
    name: 'nad',
    level: 'info',
    enabled: true
});

const circapi = require('circonusapi2');
const nadapi = require('nad_circapi');
const circwmi = require('circwmi');
const dutil = require('debug_util');


// "globals" ///////////////////////////////////////////////////////////

let booted = false;
const ext = /(?:\.([^.]+))?$/;

// cache of previous results of running scripts
// this is responded with if a script is still running when
// a request for a new value comes in (which is common with long
// running scripts that periodically output values)
const past_results = {};

// a data structure representing all scripts (aka plugins/native
// plugins.)  Each value in the object contains an object that
// has properties relating to the script.
const scripts = {};

// a collection indicating which scripts that have been run once
// already
const scripts_once = {};

let push_script = null;

// ssl credentials
const creds = {};

// The UID that we should attempt to "drop" to if specified
// on the command line so we don't have to keep running as root
let drop_uid = 0;

// The script "generation".  A global counter that's incremented
// each time we scan for new scripts on disk.
let generation = 0;

// a flag set from the command line that indicates we just want
// to run the index and then exit
let do_index = false;

// command line options for api setup
const api_options = {};
let api_setup = false;
let attempt_reverse = false;
let auth_token = null;
let target = null;
let cafile = null;
let hostname = os.hostname();
let check_bundle_id = null;
let brokerid = null;
let configfile = null;
let debugdir = null;                        // if set, a dir to write debug logs to
let wipedebugdir = false;                  // if true, wipe debug logs clean before each write
const platform = process.platform;
const is_windows = platform === 'win32';    // windows

// procre is a regular expression that captures
// the main part of a filename (i.e. without)
let procre = null;

if (is_windows) {
    procre = /^(?!\.)([^\\]*?)(?:\..*)$/;
} else {
    procre = /^(?!\.)([^/]*?)(?:\..*)$/;
}

let configdir = '/opt/circonus/etc/node-agent.d';
let port = [];
const defaultport = [ [ 2609, null ] ];
const sslport = [];
let verify = false;

// //////////////////////////////////////////////////////////////////////
// autoconfig with circonus
// //////////////////////////////////////////////////////////////////////
function configure_circonus() {
    let error = false;

    if (!(/^[0-9a-fA-F]{4}(?:[0-9a-fA-F]{4}-){4}[0-9a-fA-F]{12}$/).test(auth_token)) {
        console.log('--authtoken should be a UUID.');
        error = true;
    }
    if (target === null) {
        console.log('--target is required.');
        error = true;
    }
    if (brokerid === null || !(/^\d+$/).test(brokerid)) {
        console.log('--brokerid is required and should be an integer.');
        error = true;
    }
    if (configfile === null) {
        console.log('--configfile is required.');
        error = true;
    }
    if (error) {
        process.exit(1);
    }

    nadapi.configure(auth_token, target, hostname, brokerid, configfile, api_options);
}


// //////////////////////////////////////////////////////////////////////
// help
// //////////////////////////////////////////////////////////////////////
function help(err) {
    console.log(`${process.argv[1]}\n` +
              `\t-h\t\t\tthis help message\n` +
              `\t-i\t\t\toffline inventory\n` +
              `\t-c <configdir>\t\tconfig dir\n` +
              `\t-d\t\t\tturn on debugging messages\n` +
              `\t-p [ip:]<port>\t\tunsecured port\n` +
              `\t-s [ip:]<secureport>\tsecured port\n` +
              `\t-v\t\t\tverify secured traffic\n` +
              `\t-r\t\t\tattempt reverse connection\n` +
              `\t--authtoken\t\tCirconus API auth token to use, if passed will attempt to configure via the Circonus API then exit.\n` +
              `\t--target\t\tTarget Circonus will use to contact this host.\n` +
              `\t--hostname\t\tHostname used in check and graph names, if not passed we will attempt to look it up.\n` +
              `\t--brokerid\t\tID of the Circonus broker to configure the check on.\n` +
              `\t--cid\t\tID of the Circonus check bundle which we will use to find the proper broker for reverse connections.\n` +
              `\t--cafile\t\tpath to CA certificate file.\n` +
              `\t--configfile\t\tName of the file in the config directory to use for Circonus configuration.\n` +
              `\t--debugdir\t\tCreate debug files for each script and write them to this directory.\n` +
              `\t--wipedebugdir\t\tWipe debug files clean before each write.\n` +
              `\t--apihost\t\tOverride the host for the Circonus API server (default: api.circonus.com)\n` +
              `\t--apiport\t\tOverride the port for the Circonus API server (default: 443)\n` +
              `\t--apipath\t\tOverride the path for the Circonus API server (default: /v2)\n` +
              `\t--apiprotocol\t\tOverride the protocol for the Circonus API server (default: https)\n` +
              `\t--apiverbose\t\tOutput API traffic to STDERR\n`
            );
    if (err) {
        console.error('Error:', err);
        process.exit(-1);
    }
}

// //////////////////////////////////////////////////////////////////////
// setup optional reverse sockets
// //////////////////////////////////////////////////////////////////////


// this is a module local dict to hold the reverse connections we make
// in setup_reverse.  it exists merely to keep the connections alive which
// act as proxies and all incoming calls to this nad instance will be "pull"
// style HTTP GET requests and be handled in the normal "handler" function.
const revs = {};

let revSetupAttempts = 0;
const maxRevSetupAttempts = 5;

function getRetryInterval() {
    const minRetryInterval = 5 * 1000; // 5 seconds
    const maxRetryInterval = 30 * 1000; // 30 seconds

    return Math.floor(Math.random() * (maxRetryInterval - minRetryInterval + 1)) + minRetryInterval;
}

function setup_reverse() {
    let noit = null;

    try {
        noit = require('noit-connection');
    } catch (err) {
        logger.fatal({ error: err }, 'failed to load noit-connection module');
        // explicit request to use reverse connections but, unable to establish the connection
        // exit intentionally so there is a record in logging and service management can handle
        // a persistently failing service in its usual manner.
        process.exit(1);
    }

    function getNoitCreds() {
        let noitCreds = null;
        let credFunc = null;

        if (cafile) {
            noitCreds = noit.hashToCreds({ ca: cafile });
        } else {
            // crypto.createCredentials is deprecated in v4+
            if (typeof tls.createSecureContext === 'function') {
                credFunc = tls.createSecureContext;
            } else if (typeof crypto.createCredentials === 'function') {
                credFunc = crypto.createCredentials;
            } else {
                logger.fatal('unable to determine correct method to create secure context for reverse connection');
                process.exit(1);
            }

            noitCreds = credFunc({
                ca: [
                    '-----BEGIN CERTIFICATE-----',
                    'MIID4zCCA0ygAwIBAgIJAMelf8skwVWPMA0GCSqGSIb3DQEBBQUAMIGoMQswCQYD',
                    'VQQGEwJVUzERMA8GA1UECBMITWFyeWxhbmQxETAPBgNVBAcTCENvbHVtYmlhMRcw',
                    'FQYDVQQKEw5DaXJjb251cywgSW5jLjERMA8GA1UECxMIQ2lyY29udXMxJzAlBgNV',
                    'BAMTHkNpcmNvbnVzIENlcnRpZmljYXRlIEF1dGhvcml0eTEeMBwGCSqGSIb3DQEJ',
                    'ARYPY2FAY2lyY29udXMubmV0MB4XDTA5MTIyMzE5MTcwNloXDTE5MTIyMTE5MTcw',
                    'NlowgagxCzAJBgNVBAYTAlVTMREwDwYDVQQIEwhNYXJ5bGFuZDERMA8GA1UEBxMI',
                    'Q29sdW1iaWExFzAVBgNVBAoTDkNpcmNvbnVzLCBJbmMuMREwDwYDVQQLEwhDaXJj',
                    'b251czEnMCUGA1UEAxMeQ2lyY29udXMgQ2VydGlmaWNhdGUgQXV0aG9yaXR5MR4w',
                    'HAYJKoZIhvcNAQkBFg9jYUBjaXJjb251cy5uZXQwgZ8wDQYJKoZIhvcNAQEBBQAD',
                    'gY0AMIGJAoGBAKz2X0/0vJJ4ad1roehFyxUXHdkjJA9msEKwT2ojummdUB3kK5z6',
                    'PDzDL9/c65eFYWqrQWVWZSLQK1D+v9xJThCe93v6QkSJa7GZkCq9dxClXVtBmZH3',
                    'hNIZZKVC6JMA9dpRjBmlFgNuIdN7q5aJsv8VZHH+QrAyr9aQmhDJAmk1AgMBAAGj',
                    'ggERMIIBDTAdBgNVHQ4EFgQUyNTsgZHSkhhDJ5i+6IFlPzKYxsUwgd0GA1UdIwSB',
                    '1TCB0oAUyNTsgZHSkhhDJ5i+6IFlPzKYxsWhga6kgaswgagxCzAJBgNVBAYTAlVT',
                    'MREwDwYDVQQIEwhNYXJ5bGFuZDERMA8GA1UEBxMIQ29sdW1iaWExFzAVBgNVBAoT',
                    'DkNpcmNvbnVzLCBJbmMuMREwDwYDVQQLEwhDaXJjb251czEnMCUGA1UEAxMeQ2ly',
                    'Y29udXMgQ2VydGlmaWNhdGUgQXV0aG9yaXR5MR4wHAYJKoZIhvcNAQkBFg9jYUBj',
                    'aXJjb251cy5uZXSCCQDHpX/LJMFVjzAMBgNVHRMEBTADAQH/MA0GCSqGSIb3DQEB',
                    'BQUAA4GBAAHBtl15BwbSyq0dMEBpEdQYhHianU/rvOMe57digBmox7ZkPEbB/baE',
                    'sYJysziA2raOtRxVRtcxuZSMij2RiJDsLxzIp1H60Xhr8lmf7qF6Y+sZl7V36KZb',
                    'n2ezaOoRtsQl9dhqEMe8zgL76p9YZ5E69Al0mgiifTteyNjjMuIW',
                    '-----END CERTIFICATE-----'
                ].join('\n')
            });
        }

        creds.rejectUnauthorized = false;

        return noitCreds;
    }

    function circapi_cb(code, err, data) {
        if (err) {
            revSetupAttempts++;
            const retryInterval = getRetryInterval();

            logger.warn({
                error: err,
                code,
                data,
                attempt: revSetupAttempts,
                wait: Math.round(retryInterval / 1000)
            }, 'reverse connection setup error, trying again');

            if (revSetupAttempts >= maxRevSetupAttempts) {
                logger.fatal({ max_attempts: maxRevSetupAttempts }, 'failed to setup reverse connection after max attempts');
                // explicit request to use reverse connections but, unable to establish the connection
                // exit intentionally so there is a record in logging and service management can handle
                // a persistently failing service in its usual manner.
                process.exit(1);
            }
            setTimeout(setup_reverse, retryInterval);
            return;
        }

        if (data === null || typeof data !== 'object' || Array.isArray(data) && data.length === 0) {
            if (check_bundle_id === null) {
                logger.fatal({ hostname }, 'configuration for reverse - searching yielded no applicable json:nad check');
            } else {
                logger.fatal({ check_bundle_id }, 'configuration for reverse - unable to retrieve check object with API.');
            }
            // explicit request to use reverse connections but, incorrect configuration prevents
            // correct functionality. exit intentionally so there is a record in logging and
            // service management can handle a persistently failing service in its usual manner.
            process.exit(1);
        }

        let check = {};

        if (Array.isArray(data)) {
            check = data[0];
        } else {
            check = data;
        }

        if (!{}.hasOwnProperty.call(check, '_reverse_connection_urls')) {
            logger.fatal({ check_cid: check._cid }, 'invalid check, does not contain a reverse connection URL');
            process.exit(1);
        }

        if (!Array.isArray(check._reverse_connection_urls) || check._reverse_connection_urls.length === 0) {
            logger.fatal({ check_cid: check._cid }, 'invalid check, reverse connection URL attribute is invalid');
            process.exit(1);
        }

        check._reverse_connection_urls.forEach((rcURL) => {
            const parts = (/^mtev_reverse:\/\/(.+):(\d+)\/([^.]+)$/).exec(rcURL);

            if (parts) {
                revs[url] = new noit.connection(parts[2], parts[1], getNoitCreds());
                revs[url].reverse(parts[3], '127.0.0.1', port[0][0]);
            } else if (check._reverse_connection_urls.length === 1) {
                logger.fatal({ url: rcURL }, 'invalid reverse connection URL');
                process.exit(1);
            } else {
                logger.warn({ url: rcURL }, 'invalid reverse connection URL, skipping');
            }
        });
    }

    circapi.setup(auth_token, 'nad', api_options);

    if (check_bundle_id === null) {
        circapi.get(`/check_bundle?f_type=json:nad&f_target=${hostname}`, null, circapi_cb);
    } else {
        circapi.get(`/check_bundle/${check_bundle_id}`, null, circapi_cb);
    }
}

// //////////////////////////////////////////////////////////////////////
// setuid
// //////////////////////////////////////////////////////////////////////

function post_boot() {
    logger.info('started');

    if (process.setuid && drop_uid) {
        logger.info(`Dropping privileges: ${drop_uid}`);
        process.setuid(drop_uid);
    }

    if (attempt_reverse) {
        logger.info('setting up reverse connection');
        setup_reverse();
    }
}

// //////////////////////////////////////////////////////////////////////
// executing scripts
// //////////////////////////////////////////////////////////////////////

// utility function;  Returns the callback wrapped in an
// additional function that that stores the results in
// past results before calling the callback
function past_set_cb(cb) {
    return function past_set_cb_cb(_d, _r, _i) {
        past_results[_i] = _r;
        cb(_d, _r, _i);
    };
}

// merge_types takes two char type descriptors and returns the
// smallest type that could non-erroneously represent them
function merge_types(typeA, typeB) {
    if (typeA === typeB) {
        return typeA;
    }
    // There are four source cases where we can upgrade to int64_t
    if (typeA === 'i' && (typeB === 'I' || typeB === 'l')) {
        return 'l';
    }
    if (typeA === 'I' && (typeB === 'i' || typeB === 'l')) {
        return 'l';
    }
    if (typeA === 'l' && (typeB === 'i' || typeB === 'I')) {
        return 'l';
    }
    if (typeA === 'L' && typeB === 'I') {
        return 'l';
    }
    // otherwise we have to just jump to a double
    return 'n';
}


// runs a single script / native plugin and then fire a callback
//   d is the object for the script that's stored in 'scripts'
//   cb is what we call back when done
//   req is the request object (passed to native plugins)
//   args is any arguments that came from the per script config file
//   instance is
function run_script(def, cb, req, args, instance) {

    // mark it as running
    // (we don't re-run scripts that are still running)
    def.running = true;

    // per process data
    const proc_data = {
        // incomplete line of data buffered between
        // callbacks.  This will be
        data: '',

        // complete lines of data that have yet to
        // be handled (parsed for JSON and/or tab
        // file format.)  We only parse the output
        // when we reach the end of the output or a
        // blank line
        lines: [],

        options: {}
    };

    // mark that we're starting now
    def.last_start = Number(new Date());

    // if this is a native plugin then all we need to do
    // is call the run method on the instance stored within d.obj
    // and we're done, so return
    if (def.native_plugin) {
        def.obj.run(def, past_set_cb(cb), req, args, instance);
        return;
    }

    // execute the command
    const cmd = spawn(def.command, args);

    function kill_func() {
        cmd.stdin.destroy();
        cmd.stdout.destroy();
        cmd.stderr.destroy();
        cmd.kill();
    }

    // create a function that can handle output from the process we
    // just created.  This will be called from the code below whenever
    // we reach the end of the process output, or a blank line is found in
    // the output
    function handle_output(def2, cb2, instance2) {
        if (proc_data.timeout) {
            clearTimeout(proc_data.timeout);
        }
        def2.last_finish = Number(new Date());
        let i = null;
        let results = {};

        // if someone has specified a debug dir, then log out
        // the record we collected to that
        if (debugdir) {
            dutil.write_debug_output(def2.name, proc_data.lines, debugdir, wipedebugdir);
        }

        // attempt to process the lines as json...
        try {
            results = JSON.parse(proc_data.lines.join(' '));
        } catch (err) {
            // ... but if that doesn't work, try the tab delim format
            for (i = 0; i < proc_data.lines.length; i++) {
                const parts = (/^\s*(metric\s+)?(\S+)\s+(string|int|float|[iIlLns])(\s*)(.*)$/).exec(proc_data.lines[i]);

                if (parts) {
                    const name = parts[2];
                    let type = parts[3];
                    const space = parts[4];
                    const val = parts[5];
                    const isnull = space.length === 0 || val === '[[null]]';

                    type = type.length > 1 ? type === 'float' ? 'n' : type.substr(0, 1) : type; // eslint-disable-line no-nested-ternary

                    if (type !== 's' &&  // this is numeric
                        {}.hasOwnProperty.call(results, name) && results[name]._type !== 's' && // preexists as numeric
                        {}.hasOwnProperty.call(results[name], '_value')) {
                        if (!Array.isArray(results[name]._value)) { // upgrade to array
                            results[name]._value = [ results[name]._value ];
                        }
                        // we're in a position to append the result instead of set it.
                        results[name]._value.push(isnull ? null : val);
                        // we also might need to "upgrade the type"
                        results[name]._type = merge_types(type, results[name]._type);
                    } else {
                        results[name] = {
                            _type: type,
                            _value: isnull ? null : val
                        };
                    }
                }
            }
        }

        // remember the past results
        past_results[instance2] = results;

        // execute the callback
        cb2(def2, results, instance2);
    }

    // hook up the process so whenever we complete reading data
    // from the process we call "handle_output" and process
    // any remaining data (i.e. any partial line still in
    // our between callback buffer)
    cmd.stdout.on('end', () => {
        handle_output(def, cb, instance);
    });

    // hook up an anonymous function to the process to be called
    // whenever we get output.  The way this works is basically
    // there's two buffers used between calls: proc_data.lines
    // representing all lines of data we haven't processed yet
    // and proc_data.data representing an incomplete line
    cmd.stdout.on('data', (buff) => {
        let offset = null;

        // append output we collected to the incomplete line buffer
        // we're using to cache data between "data" callbacks
        proc_data.data += buff;

        // extract each complete line of data that's in the
        // between callback buffer and leave only the remaining
        // incomplete line in that buffer
        while ((offset = proc_data.data.indexOf('\n')) >= 0) {
            // extract a single line of data from the start of the string
            // pay attention to windows line endings if there are any!
            const line = proc_data.data.substring(0,
                     offset > 0 &&
                      proc_data.data.charAt(offset - 1) === '\r' ?
                         offset - 1 : offset);

            // is this a "comment" that contains meta information in a JSON blob?
            if (line.charAt(0) === '#') {
                try {
                    proc_data.options = JSON.parse(line.substring(1));
                } catch (err) {
                    logger.error({ err }, 'Error parsing proc otions');
                }

                // set a timeout to stop this run if requested in meta block
                if (proc_data.options.timeout) {
                    proc_data.timeout = setTimeout(kill_func,
                                         proc_data.options.timeout * 1000);
                }
            } else {
                // if this line has data in it, simply shuffle it into
                // list of lines that will need to be processed
                if (line.length) { // eslint-disable-line no-lonely-if
                    proc_data.lines.push(line);
                } else {
                    // however if the line doesn't have data in it it's a blank
                    // line, meaning we should attempt to process everything that
                    // we've collected so far up until this point
                    handle_output(def, cb, instance);
                }
            }

            // discard this line from the buffer we're using between
            // "data" callbacks and move onto processing the next one
            // if there is (or keep it for next callback if there isn't)
            proc_data.data = proc_data.data.substring(offset + 1);
        }
    });

    // when the command is done, mark it as no longer running.
    cmd.on('exit', (code, signal) => { // eslint-disable-line no-unused-vars
        def.running = false;
    });

  // if there's any error running the command, log it and remove
  // it from the list of scripts we're running
    cmd.on('error', (err) => {
        logger.error({ err, cmd: def.command }, `Error on command, removing from scripts`);
        proc_data.data = '';
        def.running = false;
        delete scripts[def.name];
    });
}

// per script config
function get_config(req, def, cb) {
    logger.debug({ name: def.name }, 'get_config');
    fs.exists(path.join(configdir, `${def.name}.json`), (exists) => {
        if (exists) {
            fs.readFile(path.join(configdir, `${def.name}.json`), (err, data) => {
                if (err) {
                    throw err;
                }
                const json_config = JSON.parse(data);
                const instance_count = Object.keys(json_config).length;

                // Add the number of time we will run this script to our
                // total run_count so we don't finish early.
                if (instance_count > 1) {
                    req.nad_run_count += instance_count - 1;
                }

                for (const instance in json_config) {
                    run_script(def, cb, req, json_config[instance], `${def.name}\`${instance}`);
                }
            });
        } else {
            run_script(def, cb, req, [], def.name);
        }
    });
}

function init_script(def, req, cb) {
    if (def.running) {
        cb(def, past_results[def.name], def.name);
        return;
    }

    get_config(req, def, cb);
}


// //////////////////////////////////////////////////////////////////////
// process commmand line arguments
// //////////////////////////////////////////////////////////////////////

for (let i = 2; i < process.argv.length; i++) {
    switch (process.argv[i]) {
        case '-d': {
            logger.level = 'debug';
            break;
        }

        // display help
        case '-h': {
            help();
            process.exit(-1);
            break;
        }

        // set the config dir
        // (internally we resolve this to the real path after processing symlinks)
        case '-c': {
            configdir = fs.realpathSync(process.argv[++i]);
            break;
        }

        // offline inventory
        case '-i': {
            do_index = true;
            break;
        }

        // switch to this uid after starting
        // (only if node supports it on the host os)
        case '-u': {
            drop_uid = parseInt(process.argv[++i], 10);
            break;
        }

        // specify one or more ports (and, optionally, IP) to listen for
        // http requests on either in the form "8080" or "127.0.0.1:8080"
        case '-p': {
            const portSpec = process.argv[++i].split(/:/);

            if (portSpec.length === 1) {
                portSpec.unshift(null);
            }
            if (portSpec.length !== 2) {
                help('-p [ip:]port');
            }
            port.push([ parseInt(portSpec[1], 10), portSpec[0] ]);
            break;
        }

        // specify one or more ports (and, optionally, IP) to listen for
        // https requests on either in the form "4443" or "127.0.0.1:4443"
        case '-s': {
            const sslPortSpec = process.argv[++i].split(/:/);

            if (sslPortSpec.length === 1) {
                sslPortSpec.unshift(null);
            }
            if (sslPortSpec.length !== 2) {
                help('-s [ip:]port');
            }
            sslport.push([ parseInt(sslPortSpec[1], 10), sslPortSpec[0] ]);
            break;
        }

        // should we verify using a certificate authority the
        // SSL certificate presented?
        case '-v': {
            verify = true;
            break;
        }

        // options for autoconfig with circonus api

        case '--authtoken': {
            auth_token = process.argv[++i];
            api_setup = true;
            break;
        }

        case '-r': {
            attempt_reverse = true;
            break;
        }

        case '--target': {
            target = process.argv[++i];
            break;
        }

        case '--cid': {
            check_bundle_id = process.argv[++i];
            break;
        }

        case '--hostname': {
            hostname = process.argv[++i];
            break;
        }

        case '--brokerid': {
            brokerid = process.argv[++i];
            break;
        }

        case '--cafile': {
            cafile = process.argv[++i];
            break;
        }

        case '--configfile': {
            configfile = fs.realpathSync(process.argv[++i]);
            break;
        }

        case '--debugdir': {
            debugdir = process.argv[++i];
            break;
        }

        case '--wipedebugdir': {
            wipedebugdir = true;
            ++i;
            break;
        }

        case '--apihost': {
            api_options.host = process.argv[++i];
            break;
        }

        case '--apiport': {
            api_options.port = process.argv[++i];
            break;
        }

        case '--apipath': {
            api_options.path = process.argv[++i];
            break;
        }

        case '--apiprotocol': {
            api_options.protocol = process.argv[++i];
            break;
        }

        case '--apiverbose': {
            api_options.verbose = true;
            break;
        }

        // unknown option, just display the helptext

        default: {
            help(`unknown argument: ${process.argv[i]}`);
        }
    }
}

if (attempt_reverse) {
    api_setup = false;
}

// if we're just indexing, do that then quit
if (do_index) {
    const index = require('indexer');

    index(configdir, is_windows, procre, ext);
    process.exit(0);
}

// if we're just setting up circonus, do that (and exit)
if (api_setup) {
    configure_circonus();
    process.exit(0);
}

// setup ports / ssl
if (port.length === 0) {
    port = defaultport;
}

if (port.length === 0 && sslport.length === 0) {
    help('must specify at least one of -p and -s');
}

if (sslport.length > 0) {
    try {
    // Setup creds
        creds.key = fs.readFileSync(path.join(configdir, 'na.key')).toString();
        creds.cert = fs.readFileSync(path.join(configdir, 'na.crt')).toString();
        if (verify) {
            creds.ca = fs.readFileSync(path.join(configdir, 'na.ca')).toString();
        }
    } catch (err) {
        logger.error('Make sure:');
        logger.error(`\tyour key is available: ${path.join(configdir, 'na.key')}`);
        logger.error(`\tyour cert is available: ${path.join(configdir, 'na.crt')}`);
        if (verify) {
            logger.error(`\tyour ca is available: ${path.join(configdir, 'na.ca')}`);
        }
        logger.error(`\n${err}`);
        process.exit(-1);
    }
}

// //////////////////////////////////////////////////////////////////////
// scanning for plugins (both native and non-native)
// //////////////////////////////////////////////////////////////////////

// a handy function returning a callback that will
// determine if a file has changed on not.
// Used by rescan_modules
function onchange(cb) {
    return function onchangecb(curr, prev) {
        if (curr.ino !== prev.ino ||
            curr.size !== prev.size ||
            curr.mtime.valueOf() !== prev.mtime.valueOf() ||
            curr.mode !== prev.mode) {
            cb();
            return;
        }
    };
}

// run each script in scripts that hasn't had an initial
// run yet (and then remember it _has_ had an initial run)
function initial_pass() {
    for (const which in scripts) {
        if (!(which in scripts_once)) {
            init_script(scripts[which], null, () => {});
            scripts_once[which] = true;
        }
    }
    if (!booted) {
        post_boot();
        booted = true;
    }
}

// look on disk for updates to the config dir where
// we keep all our modules (aka plugins / aka scripts)
function rescan_modules() {

    // this keeps track of how many filesystem stats we have
    // "in progress" and are still waiting for callbacks on
    let progress = 0;

    // this is a handy private function that goes through
    // all the scripts in our scripts object and removes
    // any that haven't had their generation number updated
    // to our current generation number once we've done
    // scanning
    function sweep() {

        // don't do this while we're still waiting for
        // stat requests that are in progress
        if (progress !== 0) {
            return;
        }

        // clear out any out of date scripts
        for (const script in scripts) {
            if (scripts[script].generation < generation) {
                fs.unwatchFile(scripts[script].command);
                delete scripts[script];
                delete scripts_once[script];
            }
        }

        // run the initial run for any new scripts
        initial_pass();
    }

    // generation is the global number of times rescan_modules has been
    // called.  Each time we rescan our modules we increase it
    // by one.
    generation++;

    // look in the config directory
    fs.readdir(configdir, (err, files) => {

        // bomb out if there's any error (we don't do any fancy
        // error handling or attempt any form of recovery)
        if (err) {
            logger.fatal({ err, dir: configdir }, 'unable to read config directory');
            process.exit(-1);
        }

        // inc our reference count
        progress++;

        // for each file in the config directory
        for (let i = 0; i < files.length; i++) {

            // check if the file is of the form something.something
            // and if it doen't match, ignore this file
            // (this regex will contain a platform dependent regex)
            const matches = procre.exec(files[i]);

            if (!matches) {
                continue;
            }

            // ignore files that are something.conf or something.json
            // these are config files, not plugins
            const extension = ext.exec(files[i])[1];

            if (extension === 'conf' || extension === 'json') {
                continue;
            }

            const filename = path.join(configdir, files[i]);

            // stop watching the file for updates
            fs.unwatchFile(filename);

            // note we need to wait for another stat callback to be
            // called before we're done
            progress++;

            // stat the file
            fs.stat(filename, (function statTest(fn, name) { // eslint-disable-line no-loop-func
                return (serr, sb) => {

                    // rewatch the file for future updates.  i.e. if the file changes
                    // again later then retrigger this rescan_modules routine
                    if (sb && sb.isFile()) {
                        fs.watchFile(fn, onchange(rescan_modules));
                    }

                    // if the file is something we should deal with
                    // (is a file, and either ends in .js or is executable, or we're running on
                    // windows where everything is considered executable)
                    if (sb && sb.isFile() && (is_windows || (/\.js$/).test(fn) || sb.mode & parseInt('0111', 8))) {
                        // setup the details in the scripts object for this file
                        if (!(name in scripts)) {
                            scripts[name] = {};
                        }
                        const def = scripts[name];

                        def.name = name;
                        def.generation = generation;
                        def.command = fn;
                        def.native_plugin = (/\.js$/).test(fn);
                        def.running = false;
                        def.sb = sb;

                        // if this is a "native plugin", i.e. a plugin written in
                        // javascript with a ".js" extension then simply load
                        // the code directly into node and then create
                        // an instance 'obj' to shove in the scripts data structure
                        if (def.native_plugin) {
                            const module = require(def.command);

                            def.obj = new module();
                        }

                        // Only remove items on initial scan
                        if (generation === 1) {
                            dutil.init_debug(name, debugdir);
                        }
                    }
                    progress--;
                    sweep();
                };
            }(filename, matches[1])));
        }
        progress--;
        sweep();
    });
}


// this is called from the "webserver" part, it's job is:
//   1. Run all scripts
//   2. Put the output as JSON into the passed result
function run_scripts(req, res, which) {
    // this is a per-request counter that lets us know
    // when all scripts have returned and it's safe to
    // stringify out the output.
    req.nad_run_count = 0;

    // this is the data structure we're going to populate
    // with the results and eventually stringify out as JSON
    const set = {};

    // called when complete to actually send 'set' out as JSON
    function send_complete() {
        if (req.nad_run_count !== 0) {
            return;
        }
        res.writeHead(200, { 'Content-Type': 'application/json' });
        res.write(JSON.stringify(set));
        res.end();
    }

    // if they asked for a particular script and it didn't exist
    // then just send a 404
    if (which && !(which in scripts)) {
        res.writeHead(404);
        res.end();
    } else {
        // otherwise we're going to populate "set" and send it back
        // either just with the script they asked for in which or,
        // if nothing was passed in which, with every script

        // first work out how many scripts we're going to wait to run
        for (const file in scripts) {
            if (which && file !== which) {
                continue;
            }
            req.nad_run_count++;
        }

        // add one for the push_script
        if (!which) {
            req.nad_run_count++;
        }

        // call init script for each script (which will run it) and
        // then when it returns in the callback populate set with
        // the result.  Keep track of how many scripts are left to run
        for (const file in scripts) {
            if (which && file !== which) {
                continue;
            }
            init_script(scripts[file], req, (def, results, name) => {
                req.nad_run_count--;
                set[name] = results;
                send_complete();  // only sends if all scripts are done
            });
        }

        // call the global push receiver script to spit out anything collected
        // over http
        if (!which) {
            init_script(push_script, req, (def, results, name) => {
                req.nad_run_count--;
                if (results !== null) {
                    for (const group in results) {
                        set[group] = results[group];
                    }
                    if (debugdir) {
                        dutil.write_debug_output(name, [ 'Returning push_receiver data', JSON.stringify(results) ], debugdir, wipedebugdir);
                    }
                }
                send_complete();  // only sends if all scripts are done
            });
        }

        send_complete(); // only sends if there were no scripts to run
    }
}

// //////////////////////////////////////////////////////////////////////
// process web requests
// //////////////////////////////////////////////////////////////////////

// this is the callback that's called whenever something connects
// to our webserver (either any of the http or the https servers)

function handler(req, res) {
    const bodyChunks = [];

    req.addListener('data', (chunk) => {
        bodyChunks.push(chunk);
    });

  // wait for the request to be completely formed (by registering
  // a callback on the 'end' event) and then send back the result
    req.addListener('end', () => {
        let matches = null;
        const urlPath = url.parse(req.url).pathname;
        const body = Buffer.concat(bodyChunks).toString();

        // request for meta-info about the scripts
        if (/^\/inventory/.test(urlPath)) {
            res.writeHead(200, { 'Content-Type': 'application/json' });
            res.write(JSON.stringify(scripts));
            res.end();
            return;
        }

        // request to run all scripts and return results
        if (/^\/(?:run)?$/.test(urlPath)) {
            run_scripts(req, res);
            return;
        }

        // request to run just one script and return results
        matches = (/^\/run\/(.+)$/).exec(path);
        if (matches) {
            run_scripts(req, res, matches[1]);
            return;
        }

        // wmi
        if ((/^\/wmi\/get-categories$/).test(path)) {
            circwmi.get_categories(res);
            return;
        }
        matches = (/^\/wmi\/(.+)$/).exec(path);
        if (matches) {
            circwmi.get_counters_for_category(res, matches[1], debugdir, wipedebugdir);
            return;
        }

        // plugin
        matches = (/^\/write\/(.+)$/).exec(path);
        if (matches) {
            if (req.method !== 'PUT' && req.method !== 'POST') {
                res.writeHead(405, 'Method Not Allowed', { Allow : 'PUT, POST' });
                res.end();
                return;
            }
            if (debugdir) {
                dutil.write_debug_output(matches[1], [ 'Receiving push_receiver data', body ], debugdir, wipedebugdir);
            }
            push_script.obj.some_data(matches[1], body);
            res.writeHead(200, 'OK', { 'Content-Type': 'text/plan' });
            res.end();
            return;
        }
        res.writeHead(404);
        res.end();
    });

    // if we don't have a data listener the stream starts paused in node 10+
    req.addListener('data', () => {});
}


// //////////////////////////////////////////////////////////////////////
// start webservers
// //////////////////////////////////////////////////////////////////////

// initialize: look for modules, and register a handler to
// rescan the modules every time the directory with the modules
// in it changes
fs.watchFile(configdir, onchange(rescan_modules));
rescan_modules();

// add our specialized push script that handles incoming POST data from any local data spurters
try {
    const module = require('push_receiver');

    push_script = {};
    push_script.name = 'dumpster';
    push_script.native_plugin = true;
    push_script.running = false;
    push_script.obj = new module();
} catch (err) {
    logger.fatal({ err }, 'unable to initialize push_receiver');
    process.exit(1);
}

// listen on all non-secure ports
try {
    for (let i = 0; i < port.length; i++) {
        logger.debug({ addr: port[i][0], port: port[i][1] }, 'starting server');
        http.createServer(handler).listen(port[i][0], port[i][1]);
    }
} catch (err) {
    logger.fatal({ port, err }, 'failed to start server');
    process.exit(-1);
}

// listen on all secure ports
try {
    for (let i = 0; i < sslport.length; i++) {
        logger.debug({ addr: sslport[i][0], port: sslport[i][1] }, 'starting SSL server');
        https.createServer(creds, handler).listen(sslport[i][0], sslport[i][1]);
    }
} catch (err) {
    logger.fatal({ sslport, err }, 'failed to start SSL server');
    process.exit(-1);
}


// //////////////////////////////////////////////////////////////////////
// done
// //////////////////////////////////////////////////////////////////////

// initial setup is all done now
// at this point if we've started servers etc the process will keep
// running even though we "fall off the end" of the code here
