#!/usr/bin/env node
// #!/bin/sh
// ':' // ; exec "$(command -v node)" --expose-gc --throw-deprecation --trace-warnings "$0" "$@"
// -*-Javascript-*-

/* eslint-disable no-process-exit */
/* eslint-disable no-sync */
/* eslint-disable no-bitwise */
/* eslint-disable no-mixed-operators */
/* eslint-disable global-require */
/* eslint-disable no-plusplus */
/* eslint-disable no-param-reassign */
/* eslint-disable guard-for-in */
/* eslit-disable no-nested-ternary */
/* eslint-disable max-params */

'use strict';

//
// Toss executables (scripts too) in /etc/node-agent.d
// Each program should produce lines as follows:
//    <name><whitespace><type>
// or:
//    <name><whitespace><type><whitespace><value>
//
// The first indicates the value is present and null
// the second indicates the value is present and specific
//

// require //////////////////////////////////////////////////////////////

const fs = require('fs');
const http = require('http');
const https = require('https');
const path = require('path');
// const spawn = require('child_process').spawn;
const url = require('url');

const settings = require('settings');
const Plugins = require('plugins');
let plugins = null;

const log = settings.logger;

log.info('initializing');

// only load if it's going to be used. (iow, if this is windows)
let circwmi = null;

if (settings.is_windows) {
    try {
        circwmi = require('circwmi');
    } catch (err) {
        const msg = 'unable to load circwmi module';

        console.error(settings.prefixError, msg, err);
        log.fatal({ err }, msg);
        process.exit(1);
    }
}

// "globals" ///////////////////////////////////////////////////////////

// listener for metrics - metrics can be 'pushed' to nad as json
// POST 127.0.0.1:2609/write with body as JSON
// (see protocol_observer usage in postgres and cassandra plugins)
let push_receiver = null;

// //////////////////////////////////////////////////////////////////////
// setuid
// //////////////////////////////////////////////////////////////////////

function post_boot() {
    settings.is_booted = true;

    if (!settings.file_watch) {
        log.info('installing SIGHUP handler to trigger plugin rescan');
        process.on('SIGHUP', () => {
            log.info('SIGHUP received, re-scanning plugins');
            plugins.scan();
        });
    }

    if (settings.drop_uid > 0 && process.setuid) {
        log.info({ uid: settings.drop_uid }, 'dropping privileges');
        process.setuid(settings.drop_uid);
    }

    if (settings.reverse.enabled) {
        log.info('setting up reverse connection');
        let reverse = null;

        try {
            reverse = require('reverse');
        } catch (err) {
            console.error(err);
            log.fatal({ err }, 'unable to set up reverse connection');
            process.exit(1);
        }

        let api_options = url.parse(settings.api.url);

        if (!settings.api.use_apiurl) {
            api_options = settings.api.old_options;
        }

        const options = {
            cafile: settings.reverse.broker_ca,
            hostname: settings.hostname,
            apiKey: settings.api.key,
            apiApp: settings.api.app,
            api_options,
            check_bundle_id: settings.reverse.check_bundle_id,
            server_port: settings.listen[0].port
        };

        reverse(options, log);
    }


    if (global.gc) {
        setInterval(() => {
            log.info('running gc');
            global.gc();
        }, 300 * 1000);
    }

    log.debug('bootstrap complete');
}

// //////////////////////////////////////////////////////////////////////
// process web requests
// //////////////////////////////////////////////////////////////////////

// this is the callback that's called whenever something connects
// to our webserver (either any of the http or the https servers)

function handler(req, res) {
    const bodyChunks = [];

    req.addListener('data', (chunk) => {
        bodyChunks.push(chunk);
    });

  // wait for the request to be completely formed (by registering
  // a callback on the 'end' event) and then send back the result
    req.addListener('end', () => {
        let matches = null;
        const urlPath = url.parse(req.url).pathname;
        const body = Buffer.concat(bodyChunks).toString();

        // request for meta-info about the scripts
        if (/^\/inventory/.test(urlPath)) {
            log.debug('inventory request');
            res.writeHead(200, { 'Content-Type': 'application/json' });
            // res.write(JSON.stringify(scripts));
            res.write(plugins.inventory());
            res.end();
            return;
        }

        // request to run all scripts and return results
        if (/^\/(?:run)?$/.test(urlPath)) {
            log.debug('running all scripts');
            plugins.run_scripts(req, res, null);
            return;
        }

        // request to run just one script and return results
        matches = (/^\/run\/(.+)$/).exec(path);
        if (matches) {
            log.debug({ script: matches[1] }, 'running plugin');
            plugins.run_scripts(req, res, matches[1]);
            return;
        }

        // wmi
        if (settings.is_windows) {
            if ((/^\/wmi\/get-categories$/).test(path)) {
                log.debug('wmi categories request');
                circwmi.get_categories(res);
                return;
            }
            matches = (/^\/wmi\/(.+)$/).exec(path);
            if (matches) {
                log.debug({ category: matches[1] }, 'wmi counters request');
                circwmi.get_counters_for_category(res, matches[1], settings.debug_dir, settings.wipe_debug_dir);
                return;
            }
        }

        // push plugin
        if (push_receiver !== null) {
            matches = (/^\/write\/(.+)$/).exec(path);
            if (matches) {
                if (req.method !== 'PUT' && req.method !== 'POST') {
                    res.writeHead(405, 'Method Not Allowed', { Allow : 'PUT, POST' });
                    res.end();
                    return;
                }
                log.debug({ name: matches[1] }, 'write request');
                log.trace({ name: matches[1], data: body }, 'write metrics');
                // if (settings.debug_dir !== null) {
                //     dutil.write_debug_output(matches[1], [ 'Receiving push_receiver data', body ], settings.debug_dir, settings.wipe_debug_dir);
                // }
                push_receiver.obj.some_data(matches[1], body);
                res.writeHead(200, 'OK', { 'Content-Type': 'text/plan' });
                res.end();
                return;
            }
        }

        // otherwise... consider it an invalid request

        log.debug({ path }, 'invalid request');
        res.writeHead(404);
        res.end();
    });

    // if we don't have a data listener the stream starts paused in node 10+
    req.addListener('data', () => {});
}

// add our specialized push script that handles incoming POST data from any local data spurters
try {
    log.debug('loading push receiver');

    let PushReceiver = null;

    try {
        PushReceiver = require('push_receiver');
    } catch (err) {
        const msg = 'failed to load push_recever module';

        console.error(settings.prefixError, msg, err);
        log.fatal({ err }, msg);
        process.exit(1);
    }

    // NOTE: this *simulates* a regular plugin
    push_receiver = {
        name: 'push_receiver',
        native_plugin: true,
        running: false,
        obj: new PushReceiver()
    };

    log.info('push receiver loaded');

} catch (err) {
    const msg = 'unable to initialize push receiver';

    console.log(settings.prefixError, msg, err);
    log.fatal({ err }, msg);
    process.exit(1);
}

plugins = new Plugins({
    plugin_dir: settings.plugin_dir,
    is_windows: settings.is_windows,
    prefixError: settings.prefixError,
    sendNADStats: settings.sendNADStats,
    debug_dir: settings.debug_dir,
    wipe_debug_dir: settings.wipe_debug_dir,
    file_watch: settings.file_watch,
    log,
    push_receiver
});

// initialize plugins

if (settings.file_watch) {
    // initialize: look for modules, and register a handler to
    // rescan the modules every time the directory with the modules
    // in it changes
    fs.watchFile(settings.plugin_dir, plugins.onchange(() => {
        log.debug({ file: settings.plugin_dir }, 'changed, triggering scan');
        plugins.scan();
    }));
}
plugins.scan(post_boot);
// rescan_modules();

// //////////////////////////////////////////////////////////////////////
// start webservers
// //////////////////////////////////////////////////////////////////////

for (const server of settings.listen) {
    log.debug({ server }, 'starting server');

    try {
        http.createServer(handler).listen(server.port, server.address);
        log.info({ server }, 'started');
    } catch (err) {
        const msg = 'failed to start server';

        console.error(settings.prefixError, msg, server, err);
        log.fatal({ server, err }, msg);
        process.exit(-1);
    }
}

for (const server of settings.ssl.listen) {
    log.debug({ server }, 'starting SSL server');

    try {
        https.createServer(settings.ssl.creds, handler).listen(server.port, server.address);
        log.info({ server }, 'started (SSL)');
    } catch (err) {
        const msg = 'failed to start SSL server';

        console.error(settings.prefixError, msg, server, err);
        log.fatal({ server, err }, msg);
        process.exit(-1);
    }
}

// END
